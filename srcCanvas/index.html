<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>30 Escenas Three.js con Gestión Perfecta de Canvas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            overscroll-behavior-y: none;
        }
        .scene-container {
            /* min-height: 20vh; */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-bottom: 1px solid #ddd;
            position: relative;
        }
        h2 {
            position: sticky;
            top: 0;
            background: rgba(255,255,255,0.9);
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            z-index: 10;
            margin: 0 0 20px 0;
        }
        .canvas-wrapper {
            width: 90%;
            height: 10vh;
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .canvas-wrapper canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
        }
        .scene-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
        }
        @media (max-width: 768px) {
            .canvas-wrapper {
                width: 95%;
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div id="scenes-root"></div>

	<script type="module">
	  import * as THREE from 'three';

        // Configuración
        const TOTAL_SCENES = 30;
        const MAX_ACTIVE_SCENES = 8; // Límite seguro para la mayoría de dispositivos
        const scenes = [];
        let activeScenesCount = 0;
        
        // Colores vibrantes para cada escena
        const colors = [
            '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#536DFE',
            '#448AFF', '#40C4FF', '#18FFFF', '#64FFDA', '#69F0AE',
            '#B2FF59', '#EEFF41', '#FFFF00', '#FFD740', '#FFAB40',
            '#FF6E40', '#FF3D00', '#795548', '#9E9E9E', '#607D8B',
            '#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#2196F3',
            '#03A9F4', '#00BCD4', '#009688', '#4CAF50', '#8BC34A'
        ];
        
        // Crear estructura HTML
        function createSceneContainers() {
            const root = document.getElementById('scenes-root');
            
            for (let i = 0; i < TOTAL_SCENES; i++) {
                const sceneElement = document.createElement('div');
                sceneElement.className = 'scene-container';
                sceneElement.id = `scene-${i}-container`;
                
                sceneElement.innerHTML = `
                    <h2>Escena ${i+1}</h2>
                    <div class="canvas-wrapper" id="canvas-wrapper-${i}">
                        <div class="loading-message">Cargando modelo 3D...</div>
                    </div>
                    <div class="scene-info" id="scene-info-${i}">Estado: Inactivo</div>
                `;
                
                root.appendChild(sceneElement);
                
                scenes.push({
                    id: i,
                    container: sceneElement,
                    canvasWrapper: document.getElementById(`canvas-wrapper-${i}`),
                    infoElement: document.getElementById(`scene-info-${i}`),
                    scene: null,
                    camera: null,
                    renderer: null,
                    mesh: null,
                    isVisible: false,
                    isInitialized: false,
                    animationId: null,
                    lastUsed: 0,
                    width: 0,
                    height: 0
                });
            }
        }
        
        // Inicializar una escena Three.js
        function initScene(sceneData) {
            const wrapper = sceneData.canvasWrapper;
            const width = wrapper.clientWidth;
            const height = wrapper.clientHeight;
            
            // Crear elemento canvas
            const canvas = document.createElement('canvas');
            sceneData.canvas = canvas;
            wrapper.innerHTML = '';
            wrapper.appendChild(canvas);
            
            // 1. Escena
            sceneData.scene = new THREE.Scene();
            sceneData.scene.background = new THREE.Color(0x111111);
            
            // 2. Cámara
            sceneData.camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            sceneData.camera.position.z = 5;
            
            // 3. Renderer
            sceneData.renderer = new THREE.WebGLRenderer({
                antialias: true,
                canvas: canvas,
                powerPreference: "high-performance",
                alpha: false
            });
            sceneData.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            sceneData.renderer.setSize(width, height, false);
            
            // 4. Geometría y material
            const geometry = new THREE.IcosahedronGeometry(1, 3);
            const material = new THREE.MeshStandardMaterial({
                color: new THREE.Color(colors[sceneData.id]),
                roughness: 0.4,
                metalness: 0.6,
                flatShading: true
            });
            
            sceneData.mesh = new THREE.Mesh(geometry, material);
            sceneData.scene.add(sceneData.mesh);
            
            // 5. Iluminación
            const ambientLight = new THREE.AmbientLight(0x404040);
            sceneData.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            sceneData.scene.add(directionalLight);
            
            // Guardar estado
            sceneData.isInitialized = true;
            sceneData.width = width;
            sceneData.height = height;
            activeScenesCount++;
            
            updateSceneInfo(sceneData, `Activa (${activeScenesCount}/${MAX_ACTIVE_SCENES})`);
        }
        
        // Liberar recursos de una escena
        function disposeScene(sceneData) {
            if (!sceneData.isInitialized) return;
            
            // 1. Detener animación
            if (sceneData.animationId) {
                cancelAnimationFrame(sceneData.animationId);
                sceneData.animationId = null;
            }
            
            // 2. Liberar recursos Three.js
            if (sceneData.mesh) {
                sceneData.mesh.geometry.dispose();
                sceneData.mesh.material.dispose();
                sceneData.scene.remove(sceneData.mesh);
                sceneData.mesh = null;
            }
            
            if (sceneData.renderer) {
                sceneData.renderer.dispose();
                sceneData.renderer.forceContextLoss();
                sceneData.renderer.domElement = null;
                sceneData.renderer = null;
            }
            
            // 3. Eliminar canvas
            if (sceneData.canvas) {
                sceneData.canvas.remove();
                sceneData.canvas = null;
                
                // Mostrar mensaje de carga
                sceneData.canvasWrapper.innerHTML = '<div class="loading-message">Cargando modelo 3D...</div>';
            }
            
            // 4. Resetear estado
            sceneData.scene = null;
            sceneData.camera = null;
            sceneData.isInitialized = false;
            activeScenesCount--;
            
            updateSceneInfo(sceneData, `Inactiva (${activeScenesCount}/${MAX_ACTIVE_SCENES})`);
        }
        
        // Animación de la escena
        function animateScene(sceneData) {
            if (!sceneData.isVisible || !sceneData.isInitialized) return;
            
            sceneData.mesh.rotation.x += 0.005;
            sceneData.mesh.rotation.y += 0.01;
            sceneData.renderer.render(sceneData.scene, sceneData.camera);
            sceneData.animationId = requestAnimationFrame(() => animateScene(sceneData));
            sceneData.lastUsed = performance.now();
        }
        
        // Actualizar información de estado
        function updateSceneInfo(sceneData, message) {
            sceneData.infoElement.textContent = message;
        }
        
        // Manejar redimensionado
        function handleResize() {
            scenes.forEach(sceneData => {
                if (sceneData.isVisible && sceneData.isInitialized) {
                    const wrapper = sceneData.canvasWrapper;
                    const newWidth = wrapper.clientWidth;
                    const newHeight = wrapper.clientHeight;
                    
                    // Solo actualizar si el tamaño cambió
                    if (Math.abs(newWidth - sceneData.width) > 1 || 
                        Math.abs(newHeight - sceneData.height) > 1) {
                        
                        // Actualizar Three.js
                        sceneData.camera.aspect = newWidth / newHeight;
                        sceneData.camera.updateProjectionMatrix();
                        sceneData.renderer.setSize(newWidth, newHeight, false);
                        
                        // Actualizar canvas
                        if (sceneData.canvas) {
                            sceneData.canvas.width = newWidth * window.devicePixelRatio;
                            sceneData.canvas.height = newHeight * window.devicePixelRatio;
                        }
                        
                        // Guardar nuevas dimensiones
                        sceneData.width = newWidth;
                        sceneData.height = newHeight;
                        
                        // Renderizar inmediatamente
                        sceneData.renderer.render(sceneData.scene, sceneData.camera);
                    }
                }
            });
        }
        
        // Configurar observadores de visibilidad y tamaño
        function setupObservers() {
            const intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const container = entry.target;
                    const sceneData = scenes.find(s => s.container === container);
                    
                    if (!sceneData) return;
                    
                    if (entry.isIntersecting) {
                        // Escena visible
                        if (!sceneData.isVisible) {
                            sceneData.isVisible = true;
                            
                            // Liberar escenas si alcanzamos el límite
                            if (activeScenesCount >= MAX_ACTIVE_SCENES) {
                                const oldestScene = scenes.reduce((oldest, current) => {
                                    return (current.isInitialized && current.lastUsed < oldest.lastUsed) ? 
                                        current : oldest;
                                }, { lastUsed: Infinity });
                                
                                if (oldestScene.isInitialized) {
                                    oldestScene.isVisible = false;
                                    disposeScene(oldestScene);
                                }
                            }
                            
                            if (!sceneData.isInitialized) {
                                initScene(sceneData);
                            }
                            animateScene(sceneData);
                        }
                    } else {
                        // Escena no visible
                        if (sceneData.isVisible) {
                            sceneData.isVisible = false;
                            disposeScene(sceneData);
                        }
                    }
                });
            }, { threshold: 0.05 });
            
            const resizeObserver = new ResizeObserver((entries) => {
                window.requestAnimationFrame(() => {
                    if (!Array.isArray(entries) || entries.length === 0) return;
                    handleResize();
                });
            });
            
            // Observar todos los contenedores
            scenes.forEach(sceneData => {
                intersectionObserver.observe(sceneData.container);
                resizeObserver.observe(sceneData.canvasWrapper);
            });
        }
        
        // Inicialización
        window.addEventListener('load', () => {
            createSceneContainers();
            setupObservers();
            
            // Manejar resize inicial
            handleResize();
            
            // Opcional: forzar garbage collection periódicamente (solo para desarrollo)
            if (window.gc) {
                setInterval(() => window.gc(), 30000);
            }
        });
        
        // Manejar evento resize con debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                handleResize();
            }, 100);
        });
    </script>
</body>
</html>